library ieee;
use ieee.numeric_std.all;

vunit formal_test(uart(rtl)) {

	default clock is rising_edge(i_clk);

	--key checks(contract) for UART functionality
	--1) correct data are transmitted
	--2) data bits are transmitted in correct order
	--3) data is received correctly 
	--transmit at some point two random data items and check that they were received correctly


	signal data_to_send : std_ulogic_vector(g_word_width-1 downto 0);
	
	type t_state is (IDLE,START_BIT,S0,S1,S2,S3,S4,S5,S6,S7,PARITY_BIT,END_BIT);
	signal send_seq : t_state;

	type t_tx_states is (IDLE,S1,S2,S3);
	signal tx_state : t_tx_states;
	signal flag_in1 : std_ulogic := '0';
	signal flag_in2 : std_ulogic := '0';

	--random values to be transmitted in succession  
	signal val_1 : std_ulogic_vector(g_word_width -1 downto 0);
	signal val_2 : std_ulogic_vector(g_word_width -1 downto 0);
	attribute anyconst : boolean;
	attribute anyconst of val_1 : signal is true;
	attribute anyconst of val_2 : signal is true;

	process(i_clk)
	begin
		if(rising_edge(i_clk)) then
			if(i_rst = '1') then
				tx_state <= IDLE;
				flag_in1 <= '0';
				flag_in2 <= '0';
			else 
				case tx_state is 
					when IDLE =>
						if(i_tx_en = '1' and o_tx_busy = '0') then
							if(i_tx_data /= val_1) then
								tx_state <= S1;
							else
								flag_in1 <= '1';
								tx_state <= S2;
							end if;
						end if;
					when S1 =>
						if(i_tx_en = '1' and o_tx_busy = '0' and i_tx_data = val_1) then
							flag_in1 <= '1';
							tx_state <= S2;
						end if;
					when S2 =>
						if(i_tx_en = '1' and o_tx_busy = '0') then
							if(i_tx_data = val_2) then
								flag_in2 <= '1';
								tx_state <= IDLE;
							else 
								tx_state <= S3;
							end if;
						end if;
					when S3 =>
						null;
					when others =>
						tx_state <= IDLE;
				end case;
			end if;
		end if;
	end process;

	process (i_clk)
	begin
		if(rising_edge(i_clk)) then
			if(i_tx_en = '1' and o_tx_busy = '0') then
				data_to_send <= i_tx_data;
			end if;
		end if;
	end process;


	process(i_clk)
	begin
		if(i_rst = '1') then
			send_seq <= IDLE;
		elsif(rising_edge(i_clk)) then
			case send_seq is
				when IDLE =>
					if(i_tx_en and (not o_tx_busy)) then
						send_seq <= START_BIT;
					end if;
				when START_BIT =>
					if(r_baud_pulse) then
						send_seq <= S0;
					end if;
				when S0 =>
					if(r_baud_pulse) then
						send_seq <= S1;
					end if;
				when S1 =>
					if(r_baud_pulse) then
						send_seq <= S2;
					end if;
				when S2 =>
					if(r_baud_pulse) then
						send_seq <= S3;
					end if;
				when S3 =>
					if(r_baud_pulse) then
						send_seq <= S4;
					end if;
				when S4 =>
					if(r_baud_pulse) then
						send_seq <= S5;
					end if;
				when S5 =>
					if(r_baud_pulse) then
						send_seq <= S6;
					end if;
				when S6 =>
					if(r_baud_pulse) then
						send_seq <= S7;
					end if;
				when S7 =>
					if(r_baud_pulse) then
						send_seq <= PARITY_BIT;
					end if;
				when PARITY_BIT =>
					if(r_baud_pulse) then
						send_seq <= END_BIT;
					end if;
				when END_BIT =>
					if(r_baud_pulse) then
						send_seq <= IDLE;
					end if;
				when others =>
					send_seq <= IDLE;
			end case;
		end if;
	end process;

	--#####################################################

	-------------------
	--ASSERT PROPERTIES
	-------------------

	-- UART TX
	--check that counters are in their valid range
	counter_baud_range: assert always {cnt_baud >=0 and cnt_baud <= range_baud};
	counter_oversample_range: assert always {cnt_oversample >=0 and cnt_oversample <= range_oversample};
	
	--check that when bits are being sent, tx_busy is asserted
	busy_when_digits: assert always {cnt_digits_send > 0} |-> {o_tx_busy = '1'};
	
	--check that when in IDLE state, busy is deasserted and tx is asserted
	idle_cond: assert always {r_state_tx = IDLE} |-> {o_tx = '1' : o_tx_busy = '0'};
	--check that when in TRANSMIT, busy is always asserted
	busy_when_transmit: assert always {r_state_tx /= IDLE} |-> {o_tx_busy = '1'};

	--check behavior of counters, always either 0 or incrementing from previous cycle
	counter_baud_behav: assert always {cnt_baud = 0 or cnt_baud = (prev(cnt_baud)+1)};
	counter_oversample_behav: assert always {cnt_oversample = 0 or cnt_oversample = (prev(cnt_oversample)+1)};

	--check that TX transmits the correct data in correct order
	seq0: assert always {send_seq = S0} |-> {o_tx = '0'}; 
	seq1: assert always {send_seq = S1} |-> {o_tx = data_to_send(0)};
	seq2: assert always {send_seq = S2} |-> {o_tx = data_to_send(1)};
	seq3: assert always {send_seq = S3} |-> {o_tx = data_to_send(2)};
	seq4: assert always {send_seq = S4} |-> {o_tx = data_to_send(3)}; 
	seq5: assert always {send_seq = S5} |-> {o_tx = data_to_send(4)};
	seq6: assert always {send_seq = S6} |-> {o_tx = data_to_send(5)};
	seq7: assert always {send_seq = S7} |-> {o_tx = data_to_send(6)};
	seq8: assert always {send_seq = PARITY_BIT} |-> {o_tx = data_to_send(7)};
	seq9: assert always {send_seq = END_BIT} |-> {o_tx = xor(data_to_send)};
	seq10: assert always {send_seq = IDLE and prev(send_seq) = END_BIT} |=> {o_tx = '1'};


	-- UART RX
	--check that cnt_oversample_pulses counter is always in the correct range
	check_oversample_pulses : assert always {cnt_oversample_pulses >=0 and cnt_oversample_pulses <= g_oversample};
	--check that cnt_digits_received counter is always in the correct range 
	check_digits_received: assert always {cnt_digits_received >=0 and cnt_digits_received <=g_word_width+2};

	--check that while data is received, o_rx_busy remains asserted 
	check_rx_busy: assert always {r_state_rx = RECEIVE} |-> {o_rx_busy = '1'};

	--check behavior of cnt_oversample_pulses counter 
	--cnt_oversample_pulses_behav: assert always {cnt_oversample_pulses = 0 or cnt_oversample_pulses = prev(cnt_oversample_pulses) or  cnt_oversample_pulses = (prev(cnt_oversample_pulses)+1)};
	--check behavior of cnt_digits_received counter 
	cnt_digits_received_behav: assert always {cnt_digits_received = 0 or cnt_digits_received = prev(cnt_digits_received) or cnt_digits_received = (prev(cnt_digits_received)+1)};

	--check that o_rx_error is never asserted, i.e no parity or end bit errors detected
	check_rx_error: assert always {o_rx_error = '0'};

	--check the transmission and reception of the two random data items
	check_tx_rx_val1: assert always (({i_tx_en = '1' and o_tx_busy ='0' and i_tx_data = val_1 and i_rst = '0'} |-> next_event(fell(o_rx_busy)) (o_rx_data = data_to_send))abort i_rst);
	check_tx_rx_val2: assert always (({i_tx_en = '1' and o_tx_busy ='0' and i_tx_data = val_2 and i_rst = '0'} |-> next_event(fell(o_rx_busy)) (o_rx_data = data_to_send))abort i_rst);
	
	--#####################################################

	-------------------
	--ASSUME PROPERTIES
	-------------------
	assume {i_rst = '1'; i_rst = '0' [*1 to inf]};

	assume {r_state_tx = IDLE};
	assume {r_state_rx = IDLE};
	assume always {i_rx = o_tx};
	assume {o_tx_busy = '0'};
	assume {i_tx_en = '0'};
	assume {cnt_baud = 0};
	assume {r_baud_pulse = '0'};
	assume {cnt_oversample = 0};
	assume {cnt_digits_send = 0};
	assume {cnt_oversample_pulses = 0};
	assume {cnt_digits_received = 0};
	assume {w_tx_parity = '0'};
	assume {send_seq = IDLE};

	assume {true[*5]; i_tx_en = '1' : o_tx_busy ='0' : i_tx_data = val_1};

	--dont latch in other data to send before rx_busy deasserts
	assume always {fell(o_tx_busy)} |-> o_tx_busy = '0' until_ fell(o_rx_busy);


	--val_1 and val_2 should be different to check againt data duplication 
	assume_diff_val : assume {val_1 /= val_2};

	--make it clear that val2 is to be written after val1
	consecutive_push: assume always {flag_in2} |-> {flag_in1};

	reset_tx_fsm : assume {tx_state = IDLE};

	assume always {i_tx_en and o_tx_busy} |-> {stable(i_tx_en) && stable(i_tx_data)};

	--#####################################################
	--cover back to back transactions of val_1 and val_2
	--cover required to avoid vacuous seccess of the check_tx_rx_val1 / check_tx_rx_val2 properties
	cover_val1_val2: cover {i_tx_en = '1' and o_tx_busy ='0' and i_tx_data = val_1 and i_rst = '0'; true[*]; (fell(o_rx_busy)) and  (o_rx_data = data_to_send); true[*];i_tx_en = '1' and o_tx_busy ='0' and i_tx_data = val_2 and i_rst = '0'; true[*]; (fell(o_rx_busy)) and  (o_rx_data = data_to_send)};
}